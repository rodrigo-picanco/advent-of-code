use std::cmp;

fn main() {
    let input = include_str!("./input1.txt");
    let output = process(input);
    dbg!(output);
}

fn process(input: &str) -> usize {
    let grid = input
        .lines()
        .map(|x| x.chars().collect::<Vec<_>>())
        .collect::<Vec<_>>();

    let empty_cols = grid[0]
        .iter()
        .enumerate()
        .map(|(i, _)| i)
        .filter_map(|y| {
            if grid.iter().find(|row| row[y] == '#').is_some() {
                None
            } else {
                Some(y)
            }
        })
        .collect::<Vec<_>>();
    println!("empty cols: {:?}", empty_cols);

    let empty_rows = grid
        .iter()
        .enumerate()
        .filter_map(|(i, row)| {
            if row.iter().all(|char| *char == '.') {
                Some(i)
            } else {
                None
            }
        })
        .collect::<Vec<_>>();
    println!("empty rows: {:?}", empty_rows);

    let galaxies: Vec<(usize, usize)> = grid
        .iter()
        .enumerate()
        .map(|(y, row)| {
            row.iter()
                .enumerate()
                .filter(|(_, char)| **char == '#')
                .map(|(x, _)| (x, y))
                .collect::<Vec<(usize, usize)>>()
        })
        .flatten()
        .collect();

    println!("galaxies: {:?}", galaxies);

    let mut result = 0;
    for i in 0..galaxies.len() {
        for j in (i+1)..galaxies.len() {
            let (xa, ya) = galaxies[i];
            let (xb, yb) = galaxies[j];
            let x1 = cmp::min(xa, xb);
            let x2 = cmp::max(xa, xb);
            let y1 = cmp::min(ya, yb);
            let y2 = cmp::max(ya, yb);

            println!("({},{})({},{})", xa, ya, xb, yb);

            let mut dist = 0;

            println!("dist: {}", dist);

            for x in (x1 + 1)..=x2 {
                dist += 1;
                if empty_rows.contains(&x) {
                    dist += 1;
                }
            }
            for y in (y1 + 1)..=y2 {

                dist += 1;
                if empty_cols.contains(&y) {
                    dist += 1;
                }
            }
            result += dist;
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_process() {
        assert_eq!(
            process(
                "\
...#......
.......#..
#.........
..........
......#...
.#........
.........#
..........
.......#..
#...#....."
            ),
            374
        );
    }
}
